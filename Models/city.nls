
;
;


to grow-cities

  update-city-populations
  
  update-city-economics
  
  apply-city-growth-patches

end


;; 
;  meso update
to update-city-populations
  
  ; gibrat update of the meso population ;
  ; then growth on patches according to distance to city-center and density saturation
  
  ask cities [
    let new-population gibrat-rate * city-population
    set delta-population new-population - city-population
    set city-population new-population
  ]
  
end


;;
; population -> economics
to update-city-economics
  
end


;;
;
to apply-city-growth-patches
  
  ;; population
  
  ask cities [
    let potential-growth-patches area-patches with [population < max-population]
    let step-pop-incr delta-population / patch-growth-steps
    
    repeat patch-growth-steps [
      let stot sum [population ^ patch-growth-alpha] of potential-growth-patches let s 0 let r random-float 1 let incr? false
      foreach to-list potential-growth-patches [set s s + ((population ^ patch-growth-alpha) / stot) if r < s and not incr? [ask ? [ask one-of (patches in-radius patch-growth-noise-radius) [set population population + step-pop-incr]]set incr? true]]
    ]
    
  ]
  
  ;; economics : idem ?
  
end



to new-city-synthetic
  ;setxy random-xcor random-ycor  
  move-to one-of (patches with [abs pxcor < max-pxcor - 15 and abs pycor < max-pycor - 15]) ;with-max [min (map [distance ?] to-list cities)]
  set shape "house" set color green set size 2
  
 
end